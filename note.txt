// server.js
import 'dotenv/config';
import express from 'express';
import http from 'http';
import path from 'path';
import fs from 'fs';
import mongoose from 'mongoose';
import { Server as SocketIO } from 'socket.io';
import { fileURLToPath } from 'url';
import morgan from 'morgan';
import session from 'express-session';
import bcrypt from 'bcrypt';

/* ---- Auth & Routers ---- */
import passport from './src/auth/passport.js';
import driverAuthRouter from './src/routes/driverAuth.js';
import adminRouter from './src/routes/admin.js';

/* ---- Models ---- */
import Ride from './src/models/Ride.js';
import Driver from './src/models/Driver.js';
import Rider from './src/models/Rider.js';
import Admin from './src/models/Admin.js';
import Activity from './src/models/Activity.js';

/* ---- Bots ---- */
import { initRiderBot, riderEvents, riderBot as RB } from './src/bots/riderBot.js';
import { initDriverBot, driverEvents, driverBot as DB } from './src/bots/driverBot.js';
import {
  initWhatsappBot,
  waitForQrDataUrl,
  isWhatsAppConnected,
  getConnectionStatus,
  sendWhatsAppMessage,
  resetWhatsAppSession,
} from './src/bots/whatsappBot.js';

/* ---- Services ---- */
import { assignNearestDriver, setEstimateOnRide, hasNumericChatId } from './src/services/assignment.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const server = http.createServer(app);
const io = new SocketIO(server, { cors: { origin: '*' } });
app.set('io', io);

const PORT = process.env.PORT || 3000;
const TRACK_LINK_TTL_HOURS = Number(process.env.TRACK_LINK_TTL_HOURS || 24);
/* ---------------- Mongo ---------------- */
await mongoose.connect(process.env.MONGODB_URI);
console.log('‚úÖ MongoDB connected');

/* ---------------- Init Bots ---------------- */
initWhatsappBot();
const riderBot = initRiderBot(io);
const driverBot = initDriverBot(io);
console.log('ü§ñ Rider bot initialized');
console.log('üöó Driver bot initialized');

/* ---------------- App setup ---------------- */
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'src/views'));
app.use(morgan('dev'));
app.use(express.static(path.join(__dirname, 'public'))); // serves /wa-qr.png and /track.html
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(
  session({
    secret: process.env.SESSION_SECRET || 'devsecret',
    resave: false,
    saveUninitialized: false,
    cookie: { maxAge: 12 * 60 * 60 * 1000 },
  })
);
app.use(passport.initialize());
app.use(passport.session());
app.use((req, res, next) => { res.locals.user = req.user || null; next(); });

/* ---------------- Seed Admin (optional) ---------------- */
async function ensureSeedAdmin() {
  const { ADMIN_EMAIL, ADMIN_PASSWORD, ADMIN_NAME } = process.env;
  if (!ADMIN_EMAIL || !ADMIN_PASSWORD) {
    console.warn('‚ö†Ô∏è Skipping admin seed: ADMIN_EMAIL/ADMIN_PASSWORD not set');
    return;
  }
  const existing = await Admin.findOne({ email: ADMIN_EMAIL });
  if (existing) return;
  const passwordHash = await bcrypt.hash(ADMIN_PASSWORD, 12);
  await Admin.create({
    name: ADMIN_NAME || 'Super Admin',
    email: ADMIN_EMAIL,
    passwordHash
  });
  console.log('üõ°Ô∏è Seeded admin:', ADMIN_EMAIL);
}
await ensureSeedAdmin();

/* ---------------- Helper: log + broadcast to admin ---------------- */
async function logActivity({
  rideId,
  type,
  message,
  actorType = 'system',
  actorId = null,
  meta = {}
}) {
  try {
    const a = await Activity.create({ rideId, type, message, actorType, actorId, meta });
    io.emit('admin:activity', {
      _id: String(a._id),
      rideId: String(rideId),
      type,
      message,
      actorType,
      actorId,
      createdAt: a.createdAt,
      meta
    });
  } catch (e) {
    console.warn('logActivity failed:', e?.message || e);
  }
}

/* ---------------- Routes ---------------- */
app.get('/', (req, res) => res.render('landing', { title: 'VayaRide' }));
app.use('/driver', driverAuthRouter);
app.use('/admin', adminRouter);

/* Rider dashboard token API (legacy) */
app.get('/api/rider-by-token/:token', async (req, res) => {
  const token = req.params.token;
  const pin = req.query.pin;
  const rider = await Rider.findOne({ dashboardToken: token });
  if (!rider) return res.status(404).json({ error: 'Rider not found' });

  const now = new Date();
  if (
    !rider.dashboardTokenExpiry ||
    rider.dashboardPin !== pin ||
    now > new Date(rider.dashboardTokenExpiry)
  ) {
    return res.status(401).json({ error: 'Access denied. PIN or token expired' });
  }

  res.json({
    chatId: rider.chatId,
    name: rider.name,
    email: rider.email,
    credit: rider.credit,
    trips: rider.trips || 0
  });
});

/* WhatsApp QR Code helpers */
app.post('/wa/reset', async (req, res) => {
  await resetWhatsAppSession();
  res.json({ ok: true, message: 'WhatsApp session reset. Open /qrcode to scan again.' });
});

app.get('/qrcode', async (req, res) => {
  if (isWhatsAppConnected()) {
    return res.send('<h2>‚úÖ WhatsApp is connected.</h2>');
  }
  try {
    const dataUrl = await waitForQrDataUrl(25000);
    res.send(`<div style="font-family:system-ui;display:grid;place-items:center;gap:12px">
      <h3>Scan to connect WhatsApp</h3>
      <img src="${dataUrl}" style="width:320px;height:320px;image-rendering:pixelated;border:8px solid #eee;border-radius:12px" />
      <p>If it stalls, refresh or try <code>/wa/reset</code>.</p>
    </div>`);
  } catch {
    const pngPath = path.join(__dirname, 'public/wa-qr.png');
    const fallback = fs.existsSync(pngPath)
      ? `<img src="/wa-qr.png" style="width:320px;height:320px;image-rendering:pixelated;border:8px solid #eee;border-radius:12px" />`
      : '<em>No QR yet. Try again shortly.</em>';
    res.send(`<div style="font-family:system-ui;display:grid;place-items:center;gap:12px">
      <h3>QR not ready</h3>${fallback}
      <p>Or call <a href="/wa/reset">/wa/reset</a> then refresh.</p>
    </div>`);
  }
});

app.get('/api/whatsapp/status', (req, res) => {
  const status = getConnectionStatus();
  res.json({ status, connected: isWhatsAppConnected() });
});

/* Profile update (dashboard) */
app.post('/api/update-profile', async (req, res) => {
  const { chatId, name, email, credit } = req.body;
  if (!chatId || isNaN(Number(chatId))) {
    return res.status(400).send('‚ùå Invalid or missing chatId.');
  }

  const rider = await Rider.findOne({ chatId: Number(chatId) });
  if (!rider) {
    return res.status(403).send('<h2>‚ùå Unauthorized: Rider not found</h2>');
  }

  rider.name = name;
  rider.email = email;
  rider.credit = credit;
  await rider.save();

  res.send('<h2>‚úÖ Profile updated securely.</h2>');
});

/* Legacy rider endpoint */
app.get('/api/rider/:chatId', async (req, res) => {
  const rider = await Rider.findOne({ chatId: req.params.chatId });
  if (!rider) return res.status(404).json({ error: 'Rider not found' });

  res.json({
    name: rider.name,
    email: rider.email,
    credit: rider.credit,
    trips: rider.trips || 0
  });
});

/* Webhook endpoints (optional; safe if using polling) */
app.post('/rider-bot', (req, res) => {
  riderBot.processUpdate?.(req.body);
  res.sendStatus(200);
});
app.post('/driver-bot', (req, res) => {
  driverBot.processUpdate?.(req.body);
  res.sendStatus(200);
});

/* Pay route */
app.use('/pay', (await import('./src/routes/payfast.js')).default);

/* Map/track page (back-compat) */
app.get('/map/:rideId', (req, res) => {
  const url = `/track.html?rideId=${encodeURIComponent(req.params.rideId)}`;
  res.redirect(302, url);
});

/* ---------------- Tracking APIs ---------------- */

function isRideLinkExpired(ride) {
  // terminal states always expire the link
  if (['cancelled', 'completed', 'payment_pending'].includes(ride.status)) {
    return { expired: true, reason: ride.status };
  }
  // TTL expiry for stale links (optional)
  if (TRACK_LINK_TTL_HOURS > 0) {
    const made = new Date(ride.createdAt || Date.now());
    const expiresAt = new Date(made.getTime() + TRACK_LINK_TTL_HOURS * 3600 * 1000);
    if (Date.now() > +expiresAt) {
      return { expired: true, reason: 'ttl', expiresAt };
    }
  }
  return { expired: false, reason: null };
}

app.get('/api/ride/:rideId', async (req, res) => {
  try {
    const ride = await Ride.findById(req.params.rideId).lean();
    if (!ride) return res.status(404).json({ error: 'Ride not found' });

    // Expiry gate: cancel/completed/ttl
    const exp = isRideLinkExpired(ride);
    if (exp.expired) {
      return res.status(410).json({
        error: 'expired',
        status: ride.status,
        reason: exp.reason,                // 'cancelled' | 'completed' | 'payment_pending' | 'ttl'
        createdAt: ride.createdAt,
        cancelledAt: ride.cancelledAt || null,
        completedAt: ride.completedAt || null,
        expiresAt: exp.expiresAt || null
      });
    }

    // Provide extra fields the client can use to hold state
    let driverChatId = null;
    if (ride.driverId) {
      const drv = await Driver.findById(ride.driverId).lean();
      if (drv && typeof drv.chatId === 'number') driverChatId = drv.chatId;
    }

    res.json({
      pickup: ride.pickup,
      destination: ride.destination,
      status: ride.status || 'pending',
      driverChatId,
      // optional: send known timing so rider page can persist ETA-ish UI on refresh
      pickedAt: ride.pickedAt || ride.startedAt || null,
      completedAt: ride.completedAt || null,
      createdAt: ride.createdAt
    });
  } catch (e) {
    res.status(500).json({ error: 'Server error' });
  }
});

app.get('/api/driver-last-loc/:chatId', async (req, res) => {
  try {
    const chatId = Number(req.params.chatId);
    if (Number.isNaN(chatId)) return res.status(400).json({});
    const driver = await Driver.findOne({ chatId }).lean();
    if (!driver || !driver.location) {
      console.log(`‚ÑπÔ∏è No last location for driver chatId=${chatId}`);
      return res.json({});
    }
    console.log(`‚Ü©Ô∏è API last loc chatId=${chatId} lat=${driver.location.lat} lng=${driver.location.lng}`);
    res.json(driver.location);
  } catch {
    res.json({});
  }
});

/* -------- live driver tickers (per driver) -------- */
const lastLocByDriver = new Map();     // chatId -> { lat, lng, ts }
const tickerByDriver = new Map();      // chatId -> intervalId

function stopDriverTicker(chatId) {
  const id = tickerByDriver.get(Number(chatId));
  if (id) {
    clearInterval(id);
    tickerByDriver.delete(Number(chatId));
  }
  lastLocByDriver.delete(Number(chatId));
}

/* ‚≠ê NEW: in-memory "arrived" dedupe per ride */
const arrivedAnnounced = new Set(); // Set(rideId)

/* ---------------- utilities ---------------- */
// haversine distance in meters
function haversineMeters(a, b) {
  const toRad = (x)=> x * Math.PI / 180;
  const R = 6371000;
  const dLat = toRad(b.lat - a.lat);
  const dLon = toRad(b.lng - a.lng);
  const s = Math.sin(dLat/2)**2 + Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLon/2)**2;
  return 2 * R * Math.asin(Math.sqrt(s));
}

/* ---------------- Live driver broadcasts (per-driver + per-ride) ---------------- */
driverEvents.on('driver:location', async ({ chatId, location }) => {
  try {
    const cId = Number(chatId);
    const { lat, lng } = location || {};
    if (typeof lat !== 'number' || typeof lng !== 'number') return;

    lastLocByDriver.set(cId, { lat, lng, ts: Date.now() });

    io.emit(`driver:${cId}:location`, { lat, lng });

    // find active ride for this driver
    const drv = await Driver.findOne({ chatId: cId }).select('_id').lean();
    if (drv?._id) {
      const ride = await Ride.findOne({
        driverId: drv._id,
        status: { $in: ['accepted', 'enroute'] }
      }).sort({ updatedAt: -1 }).lean();

      if (ride?._id) {
        io.emit(`ride:${ride._id}:driverLocation`, { lat, lng });

        // ‚≠ê server-side arrival auto-detect (when status is 'accepted')
        if (ride.status === 'accepted' && ride.pickup?.lat && ride.pickup?.lng && !arrivedAnnounced.has(String(ride._id))) {
          const dMeters = haversineMeters({ lat, lng }, ride.pickup);
          if (dMeters <= 35) {
            arrivedAnnounced.add(String(ride._id));
            // notify rider via existing pipeline
            driverEvents.emit('ride:arrived', { driverId: chatId, rideId: String(ride._id) });
            // also tell any open maps to show the modal
            io.emit(`ride:${ride._id}:arrived`);
          }
        }
      }
    }

    // keep light heartbeat
    if (!tickerByDriver.has(cId)) {
      const id = setInterval(async () => {
        const last = lastLocByDriver.get(cId);
        if (!last) return;

        const staleMs = Date.now() - last.ts;
        if (staleMs > 2 * 60 * 1000) {
          stopDriverTicker(cId);
          return;
        }

        io.emit(`driver:${cId}:location`, { lat: last.lat, lng: last.lng });

        try {
          const drv2 = await Driver.findOne({ chatId: cId }).select('_id').lean();
          if (!drv2?._id) return;
          const active = await Ride.findOne({
            driverId: drv2._id,
            status: { $in: ['accepted', 'enroute'] }
          }).sort({ updatedAt: -1 }).select('_id').lean();
          if (active?._id) {
            io.emit(`ride:${active._id}:driverLocation`, { lat: last.lat, lng: last.lng });
          }
        } catch {}
      }, 1000);
      tickerByDriver.set(cId, id);
    }
  } catch (e) {
    console.warn('driver:location broadcast failed:', e?.message || e);
  }
});

/* ---------------- BOOKING DISPATCH PIPELINE ---------------- */
async function dispatchToNearestDriver({ rideId, excludeDriverIds = [] }) {
  const ride = await Ride.findById(rideId);
  if (!ride || ride.status !== 'pending') return;

  const chosen = await assignNearestDriver(ride.pickup, {
    vehicleType: ride.vehicleType || null,
    exclude: excludeDriverIds
  });

  if (!chosen || !hasNumericChatId(chosen)) {
    try { if (ride.riderChatId) await RB.sendMessage(ride.riderChatId, 'üòï No drivers are available right now. We will keep trying shortly.'); } catch {}
    try { if (ride.riderWaJid)  await sendWhatsAppMessage(ride.riderWaJid, 'üòï No drivers are available right now. We will keep trying shortly.'); } catch {}
    return;
  }

  try { await setEstimateOnRide(ride._id, chosen.location || null); } catch {}

  await logActivity({
    rideId: ride._id,
    type: 'assigned',
    actorType: 'system',
    message: `Assigned to driver ${chosen.name || chosen.email || chosen.chatId || chosen._id}`,
    meta: { driverId: String(chosen._id), driverChatId: chosen.chatId ?? null }
  });

  const toMap = ({ lat, lng }) => `https://maps.google.com/?q=${lat},${lng}`;
  const text =
    `üöó <b>New Ride Request</b>\n\n` +
    `‚Ä¢ Vehicle: <b>${(ride.vehicleType || 'normal').toUpperCase()}</b>\n` +
    (ride.estimate ? `‚Ä¢ Estimate: <b>R${ride.estimate}</b>\n` : '') +
    `‚Ä¢ Pickup: <a href="${toMap(ride.pickup)}">Open Map</a>\n` +
    `‚Ä¢ Drop:   <a href="${toMap(ride.destination || ride.pickup)}">Open Map</a>\n\n` +
    `Accept to proceed.`;

  try {
    await DB.sendMessage(chosen.chatId, text, {
      parse_mode: 'HTML',
      reply_markup: {
        inline_keyboard: [[
          { text: '‚úÖ Accept', callback_data: `accept_${ride._id}` },
          { text: 'üôà Ignore', callback_data: `ignore_${ride._id}` }
        ]]
      }
    });
  } catch (e) {
    console.warn('Failed to DM driver request:', e?.message || e);
  }
}

riderEvents.on('booking:new', async ({ rideId }) => {
  try {
    if (!rideId) return;
    await logActivity({ rideId, type: 'request', actorType: 'rider', message: 'Rider requested a trip' });
    await dispatchToNearestDriver({ rideId });
  } catch (e) { console.error('booking:new handler error:', e?.message || e); }
});

driverEvents.on('ride:ignored', async ({ previousDriverId, ride }) => {
  try {
    if (!ride || !ride._id) return;
    await logActivity({
      rideId: ride._id,
      type: 'ignored',
      actorType: 'driver',
      actorId: String(previousDriverId),
      message: `Driver ${previousDriverId} ignored the ride`
    });
    const prevDriver = await Driver.findOne({ chatId: Number(previousDriverId) }).lean();
    const excludeIds = prevDriver ? [prevDriver._id] : [];
    await dispatchToNearestDriver({ rideId: String(ride._id), excludeDriverIds: excludeIds });
  } catch (e) { console.error('ride:ignored handler error:', e?.message || e); }
});

/* ‚ûï When the driver accepts, send THEM a driver-mode link that streams HTML5 GPS */
driverEvents.on('ride:accepted', async ({ driverId, rideId }) => {
  try {
    const ride = await Ride.findById(rideId);
    if (!ride) return;

    if (!ride.driverId) {
      const drv = await Driver.findOne({ chatId: Number(driverId) });
      if (drv) { ride.driverId = drv._id; await ride.save(); }
    }

    await logActivity({
      rideId,
      type: 'accepted',
      actorType: 'driver',
      actorId: String(driverId),
      message: `Driver ${driverId} accepted the ride`
    });

    const base = `${process.env.PUBLIC_URL}/track.html?rideId=${encodeURIComponent(rideId)}`;
    const riderLink  = base;
    const driverLink = `${base}&as=driver&driverChatId=${encodeURIComponent(driverId)}`;

    try { if (ride.riderChatId) await RB.sendMessage(ride.riderChatId, `üöó Your ride is on the way. Track here:\n${riderLink}`); } catch {}
    try { if (ride.riderWaJid)  await sendWhatsAppMessage(ride.riderWaJid, `üöó Your ride is on the way. Track here:\n${riderLink}`); } catch {}
    try { await DB.sendMessage(driverId, `üó∫Ô∏è Open the live trip map (shares your GPS):\n${driverLink}`); } catch {}
  } catch (e) {
    console.warn('ride:accepted handler failed:', e?.message || e);
  }
});

/* ‚≠ê CHG: when arrived, also emit a socket event so the map modal can show */
driverEvents.on('ride:arrived', async ({ rideId }) => {
  try {
    const ride = await Ride.findById(rideId);
    if (!ride) return;

    await logActivity({
      rideId,
      type: 'arrived',
      actorType: 'driver',
      message: 'Driver arrived at pickup'
    });

    try { if (ride.riderChatId) await RB.sendMessage(ride.riderChatId, 'üìç Your driver has arrived at the pickup point.'); } catch {}
    try { if (ride.riderWaJid)  await sendWhatsAppMessage(ride.riderWaJid, 'üìç Your driver has arrived at the pickup point.'); } catch {}

    // ‚≠ê Tell any open clients to pop arrival UI.
    io.emit(`ride:${rideId}:arrived`);
  } catch (e) {
    console.warn('ride:arrived handler failed:', e?.message || e);
  }
});

/* ‚≠ê NEW: picked event (for admin activity feed) */
driverEvents.on('ride:picked', async ({ rideId, by }) => {
  try {
    await logActivity({
      rideId,
      type: 'picked',
      actorType: 'driver',
      message: 'Rider picked up',
      meta: { by: by || 'unknown' }
    });
    // We purposefully do NOT notify the rider here to avoid duplicate pings.
  } catch (e) {
    console.warn('ride:picked handler failed:', e?.message || e);
  }
});

/* ‚≠ê UPDATED: handle started without double-notifying if origin already messaged rider */
driverEvents.on('ride:started', async ({ rideId, by }) => {
  try {
    const ride = await Ride.findById(rideId);
    if (!ride) return;

    // ‚≠ê clear dedupe so future rides can re-announce
    arrivedAnnounced.delete(String(rideId));

    await logActivity({
      rideId,
      type: 'started',
      actorType: 'driver',
      message: 'Trip started',
      meta: { by: by || 'unknown' }
    });

    // If the origin already notified the rider (web/driver_bot), skip duplicate
    const origin = (by || '').toLowerCase();
    const skipNotify = origin === 'web' || origin === 'driver_bot';
    if (skipNotify) return;

    try { if (ride.riderChatId) await RB.sendMessage(ride.riderChatId, '‚ñ∂Ô∏è Your trip has started. Enjoy the ride!'); } catch {}
    try { if (ride.riderWaJid)  await sendWhatsAppMessage(ride.riderWaJid, '‚ñ∂Ô∏è Your trip has started. Enjoy the ride!'); } catch {}
  } catch (e) {
    console.warn('ride:started handler failed:', e?.message || e);
  }
});

/* ---------------- Start Trip API (driver clicks Start in map UI) ---------------- */
app.post('/api/ride/:rideId/start', async (req, res) => {
  try {
    const { rideId } = req.params;
    const ride = await Ride.findById(rideId);
    if (!ride) return res.status(404).json({ error: 'Ride not found' });

    if (!['enroute','completed','cancelled'].includes(ride.status)) {
      ride.status = 'enroute';
      await ride.save();
    }

    const riderChatId =
      ride.riderChatId ||
      ride.riderTelegramChatId ||
      ride.rider?.chatId ||
      null;

    if (riderChatId && riderBot) {
      try {
        await riderBot.sendMessage(
          Number(riderChatId),
          'üöó Your driver has started the trip and is heading to you.'
        );
      } catch (err) {
        console.error('Failed to message rider on Telegram:', err?.message || err);
      }
    }

    try {
      driverEvents.emit('ride:started', { rideId: ride._id.toString(), by: 'web' });
    } catch {}

    return res.json({ ok: true });
  } catch (err) {
    console.error('POST /api/ride/:rideId/start error', err);
    return res.status(500).json({ error: 'Internal error' });
  }
});

/* ---------------- Picked Up API (driver clicks Picked in map UI) ---------------- */
app.post('/api/ride/:rideId/picked', async (req, res) => {
  try {
    const { rideId } = req.params;
    const ride = await Ride.findById(rideId);
    if (!ride) return res.status(404).json({ error: 'Ride not found' });

    if (!['enroute','completed','cancelled'].includes(ride.status)) {
      ride.status = 'enroute';
      await ride.save();
    }

    const riderChatId =
      ride.riderChatId ||
      ride.riderTelegramChatId ||
      ride.rider?.chatId ||
      null;

    if (riderChatId && riderBot) {
      try {
        await riderBot.sendMessage(
          Number(riderChatId),
          '‚úÖ You have been picked up. Heading to your destination now.'
        );
      } catch (err) {
        console.error('Failed to message rider on Telegram (picked):', err?.message || err);
      }
    }

    try {
      driverEvents.emit('ride:picked', { rideId: ride._id.toString(), by: 'web' });
    } catch {}

    return res.json({ ok: true });
  } catch (err) {
    console.error('POST /api/ride/:rideId/picked error', err);
    return res.status(500).json({ error: 'Internal error' });
  }
});

/* ---------------- Cancel Trip API (driver clicks Cancel in map UI) ---------------- */
/**
 * - Sets status to 'cancelled'
 * - Notifies the rider on Telegram with provided reason (and optional note)
 * - Logs activity for the admin feed
 */
app.post('/api/ride/:rideId/cancel', async (req, res) => {
  try {
    const { rideId } = req.params;
    const { reason, note } = req.body || {};
    const ride = await Ride.findById(rideId);
    if (!ride) return res.status(404).json({ error: 'Ride not found' });

    // Update status
    if (ride.status !== 'cancelled') {
      ride.status = 'cancelled';
      try {
        // If your schema allows, you can keep these fields;
        // if not, they‚Äôll be ignored silently.
        ride.cancellationReason = reason || null;
        ride.cancellationNote = note || null;
        ride.cancelledAt = new Date();
        ride.cancelledBy = 'driver';
      } catch {}
      await ride.save();
    }

    // Notify rider via Telegram (requested)
    const riderChatId =
      ride.riderChatId ||
      ride.riderTelegramChatId ||
      ride.rider?.chatId ||
      null;

    if (riderChatId && riderBot) {
      const cleanReason = String(reason || 'Trip cancelled').trim();
      const cleanNote = (note ? String(note).trim() : '');
      const msg =
        `‚ùå <b>Your trip was cancelled by the driver.</b>\n` +
        `‚Ä¢ Reason: <i>${cleanReason}</i>` +
        (cleanNote ? `\n‚Ä¢ Note: ${cleanNote}` : '');
      try {
        await riderBot.sendMessage(Number(riderChatId), msg, { parse_mode: 'HTML' });
      } catch (e) {
        console.error('Failed to notify rider on Telegram (cancel):', e?.message || e);
      }
    }

    // Log activity for admin
    await logActivity({
      rideId: ride._id,
      type: 'cancelled',
      actorType: 'driver',
      message: `Ride cancelled (${reason || 'unspecified'})`,
      meta: { reason: reason || null, note: note || null }
    });

    // Broadcast to any connected UIs if you want:
    try { io.emit(`ride:${rideId}:cancelled`, { reason: reason || null }); } catch {}

    return res.json({ ok: true });
  } catch (err) {
    console.error('POST /api/ride/:rideId/cancel error', err);
    return res.status(500).json({ error: 'Internal error' });
  }
});


/* ==== Fare table + helpers (server-side) ================================== */
/* Put this ABOVE the /api/ride/:rideId/finish route */

const RATE_TABLE = {
  normal:  { baseFare: 0, perKm: 7,  minCharge: 30, withinKm: 30 },
  comfort: { baseFare: 0, perKm: 8,  minCharge: 30, withinKm: 30 },
  luxury:  { baseFare: 0, perKm: 12, minCharge: 45, withinKm: 45 },
  xl:      { baseFare: 0, perKm: 10, minCharge: 39, withinKm: 40 }
};

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function haversineKm(a, b){
  if (!a || !b || typeof a.lat!=='number' || typeof a.lng!=='number' || typeof b.lat!=='number' || typeof b.lng!=='number') return 0;
  const toRad = (x)=> x * Math.PI / 180;
  const R = 6371; // km
  const dLat = toRad(b.lat - a.lat);
  const dLon = toRad(b.lng - a.lng);
  const s = Math.sin(dLat/2)**2 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.sin(dLon/2)**2;
  return 2 * R * Math.asin(Math.sqrt(s));
}

function pathLengthKm(path){
  if (!Array.isArray(path) || path.length < 2) return 0;
  let km = 0;
  for (let i = 1; i < path.length; i++){
    const p0 = path[i-1], p1 = path[i];
    if (!p0 || !p1) continue;
    km += haversineKm({lat:p0.lat, lng:p0.lng}, {lat:p1.lat, lng:p1.lng});
  }
  return km;
}

function expectedDurationSec(distanceKm, avgKph = 30){
  // simple city-driving heuristic
  const hours = distanceKm / Math.max(1, avgKph);
  return Math.round(hours * 3600);
}

function priceFromRate(distanceKm, vehicleType='normal'){
  const vt = RATE_TABLE[vehicleType] ? vehicleType : 'normal';
  const rate = RATE_TABLE[vt];
  const d = Math.max(0, Number(distanceKm || 0));

  const within = rate.withinKm ?? 0;
  const variable = d <= within ? 0 : (rate.perKm ?? 0) * (d - within);

  const base = (rate.baseFare ?? 0) + (rate.minCharge ?? 0) + variable;
  return Math.round(base);
}

/**
 * computeFinalFare
 * Returns:
 *  {
 *    price: number,          // final R amount (int)
 *    tripKm: number,         // km (float)
 *    actualDurationSec: number,
 *    expectedDurationSec: number,
 *    trafficFactor: number,  // ratio actual/expected (clamped)
 *    surge: number           // 1.0 unless you add surge logic
 *  }
 */
async function computeFinalFare({
  pickup,
  destination,
  vehicleType = 'normal',
  path = null,             // optional array of {lat,lng}
  createdAt = null,
  pickedAt = null,
  completedAt = new Date()
} = {}) {
  // 1) Distance
  let tripKm = 0;
  if (Array.isArray(path) && path.length >= 2) {
    tripKm = pathLengthKm(path);
  } else {
    // straight-line * 1.25 fudge to approximate route
    const sl = haversineKm(pickup, destination);
    tripKm = sl * 1.25;
  }
  tripKm = Number.isFinite(tripKm) ? tripKm : 0;

  // 2) Durations
  const startTs = pickedAt ? new Date(pickedAt).getTime() : (createdAt ? new Date(createdAt).getTime() : Date.now());
  const endTs   = completedAt ? new Date(completedAt).getTime() : Date.now();
  const actualDurationSecVal = Math.max(0, Math.round((endTs - startTs) / 1000));

  const expectedSec = expectedDurationSec(tripKm, 30);
  const tf = expectedSec > 0 ? clamp(actualDurationSecVal / expectedSec, 0.6, 2.5) : 1.0;

  // 3) Surge logic (off by default; wire your own triggers)
  const surge = 1.0;

  // 4) Price
  let price = priceFromRate(tripKm, vehicleType);

  // If you want traffic to affect price slightly, uncomment:
  // price = Math.round(price * clamp(0.9 * tf, 0.8, 1.5));

  return {
    price,
    tripKm: Number(tripKm.toFixed(3)),
    actualDurationSec: actualDurationSecVal,
    expectedDurationSec: expectedSec,
    trafficFactor: Number(tf.toFixed(2)),
    surge
  };
}
/* ==== end helpers ========================================================= */

/* ---------------- Finish Trip API (driver clicks Finish in map UI) ---------------- */
/**
 * Body: { paidMethod?: 'cash' | 'app' }
 * Effects:
 *  - Sets status to 'completed'
 *  - Persists payment meta
 *  - Notifies rider on Telegram
 *  - Emits socket event ride:<id>:finished
 *  - Logs admin activity
 */
app.post('/api/ride/:rideId/finish', async (req, res) => {
  try {
    const { rideId } = req.params;
    const { paidMethod } = req.body || {};
    const ride = await Ride.findById(rideId);
    if (!ride) return res.status(404).json({ error: 'Ride not found' });

    // compute dynamic final fare using actuals
    const {
      price,
      tripKm,
      actualDurationSec,
      expectedDurationSec,
      trafficFactor,
      surge
    } = await computeFinalFare({
      pickup: ride.pickup,
      destination: ride.destination,
      vehicleType: ride.vehicleType || 'normal',
      path: ride.path || null,
      createdAt: ride.createdAt,
      pickedAt: ride.pickedAt || ride.startedAt || ride.createdAt,
      completedAt: new Date(),
      // (optional) driverStartLocation: ride.driverStartLocation
    });

    // persist summary onto ride
    ride.status = 'completed';
    ride.completedAt = new Date();
    ride.paymentMethod = (paidMethod === 'cash' || paidMethod === 'app') ? paidMethod : 'app';
    ride.finalAmount = price;
    ride.finalDistanceKm = tripKm;
    ride.finalDurationSec = actualDurationSec;
    ride.finalTrafficFactor = trafficFactor;
    ride.finalSurge = surge;
    await ride.save();

    // push to live trip page listeners
    io.emit(`ride:${rideId}:finished`, {
      paidMethod: ride.paymentMethod,
      amount: price,
      distanceKm: tripKm
    });

    // also answer the XHR that called /finish (driver page)
    return res.json({
      ok: true,
      paidMethod: ride.paymentMethod,
      amount: price,
      distanceKm: tripKm,
      durationSec: actualDurationSec
    });
  } catch (e) {
    console.error('finish error', e);
    res.status(500).json({ error: 'Failed to finish trip' });
  }
});


/* ---------------- Socket.IO ---------------- */
io.on('connection', (sock) => {
  console.log('üîå Socket connected:', sock.id);

  /* Driver‚Äôs browser can stream HTML5 GPS */
  sock.on('driver:mapLocation', async (payload = {}) => {
    try {
      const { rideId, chatId, lat, lng } = payload || {};
      if (!rideId || !Number.isFinite(Number(chatId))) return;
      if (typeof lat !== 'number' || typeof lng !== 'number') return;

      // Validate: this chatId must be the driver assigned to this ride
      const ride = await Ride.findById(rideId).lean();
      if (!ride || !ride.driverId) return;

      const drv = await Driver.findById(ride.driverId).lean();
      if (!drv || Number(drv.chatId) !== Number(chatId)) return;

      // Update DB so /api/driver-last-loc works as well
      await Driver.findOneAndUpdate(
        { _id: drv._id },
        { $set: { location: { lat, lng }, lastSeenAt: new Date(), isAvailable: true } },
        { new: true }
      );

      // Reuse the same broadcast path as Telegram updates
      driverEvents.emit('driver:location', { chatId: Number(chatId), location: { lat, lng } });
    } catch (e) {
      console.warn('driver:mapLocation error:', e?.message || e);
    }
  });
});

/* ---------------- Start server ---------------- */
server.listen(PORT, () => {
  console.log(`üöÄ Server is running at http://localhost:${PORT}`);
});
